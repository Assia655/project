name: CI/CD Pipeline

on:
  push:
    branches:
      - main  # Exécuter le pipeline pour les pushes dans la branche main.

jobs:
  build-push-deploy:
    name: Build, Push to Docker Hub, and Deploy to Kubernetes
    runs-on: ubuntu-latest

    steps:
      # Étape 1 : Vérifier le code source
      - name: Checkout Code
        uses: actions/checkout@v3

      # Étape 2 : Se connecter à Docker Hub
      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Étape 3 : Construire et pousser les images Docker pour chaque microservice
      - name: Build and Push User Service
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/backend-user_service:v2 ./backend/user_service
          docker push ${{ secrets.DOCKER_USERNAME }}/backend-user_service:v2

      - name: Build and Push Transaction Service
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/backend-transaction_service:v1 ./backend/transaction_service
          docker push ${{ secrets.DOCKER_USERNAME }}/backend-transaction_service:v1

      - name: Build and Push Price Service
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/backend-price_service:v1 ./backend/price_service
          docker push ${{ secrets.DOCKER_USERNAME }}/backend-price_service:v1

      - name: Build and Push API Gateway
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/backend-api_gateway:latest ./backend/api-gateway
          docker push ${{ secrets.DOCKER_USERNAME }}/backend-api_gateway:latest

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
         version: 'v1.30.5'

      # Étape 4 : Configurer kubectl avec kubeconfig
      - name: Configure kubeconfig
        run: |
           mkdir -p ~/.kube  # Créer le répertoire ~/.kube s'il n'existe pas
           echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
           chmod 600 ~/.kube/config


      - name: Validate Kubernetes Connection
        run: |
           kubectl cluster-info
           kubectl get nodes

    

      # Étape 5 : Appliquer les fichiers Kubernetes pour déployer les microservices
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f ./backend/kubernetes/user-service-deployment.yml
          kubectl apply -f ./backend/kubernetes/user-service.yml
          kubectl apply -f ./backend/kubernetes/transaction-service-deployment.yaml
          kubectl apply -f ./backend/kubernetes/transaction-service-service.yaml
          kubectl apply -f ./backend/kubernetes/price-service-deployment.yaml
          kubectl apply -f ./backend/kubernetes/price-service-service.yaml
          kubectl apply -f ./backend/kubernetes/api-gateway-deployment.yaml
          kubectl apply -f ./backend/kubernetes/api-gateway-service.yaml
          kubectl apply -f ./backend/kubernetes/kafka-deployment.yaml
          kubectl apply -f ./backend/kubernetes/kafka-service.yaml
          kubectl apply -f ./backend/kubernetes/zookeeper-deployment.yaml
          kubectl apply -f ./backend/kubernetes/zookeeper-service.yaml

      # Étape 6 : Vérifier l'état des déploiements
      - name: Verify Rollout Status for All Services
        run: |
          kubectl rollout status deployment/user-service
          kubectl rollout status deployment/transaction-service
          kubectl rollout status deployment/price-service
          kubectl rollout status deployment/api-gateway

      # Étape 7 : Vérifier les Pods déployés
      - name: Verify Deployed Pods
        run: kubectl get pods

      # Étape 8 : Rollback automatique en cas d'échec
      - name: Rollback on Failure
        if: failure()  # Exécute cette étape uniquement si une étape précédente échoue
        run: |
          kubectl rollout undo deployment/user-service
          kubectl rollout undo deployment/transaction-service
          kubectl rollout undo deployment/price-service
          kubectl rollout undo deployment/api-gateway


